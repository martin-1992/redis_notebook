# redis 笔记

### [Redis 事务](https://github.com/martin-1992/redis_notebook/tree/master/Redis%20%E4%BA%8B%E5%8A%A1)
　　非原子性的，有一条命令失败，也会执行下去，**本质是将多条命令放到一起执行。** <br />

- MULTI 命令，表示事务开始。这时开始输入其他命令，会进入 redis 的命令事务队列；
- EXEC 表示事务执行，redis 会执行事务队列中的命令；
- DISCARD 表示丢弃事务队列中的所有命令，Redis 不支持回滚操作。

### Redis 乐观锁
　　WATCH 命令是一个乐观锁，原理为 CAS，检查被监视的键是否有修改过，是则拒绝执行事务。

### [Redis 持久化机制](https://github.com/martin-1992/redis_notebook/tree/master/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6)
　　将内存的数据保存到磁盘中，防止机器意外断电、重启导致数据丢失。Redis 有两种持久化方法：

- RDB 持久化，快照形式，全量备份。生成一个压缩的二进制文件 RDB 文件，保存的是数据库的键值对数据；
- AOF 持久化，增量备份。每隔一段时间（比如每隔一秒）保存 Redis 服务器所执行的写命令。

### [Redis 过期机制](https://github.com/martin-1992/redis_notebook/tree/master/Redis%20%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6)
　　Redis 的过期策略为定期删除 + 惰性删除。注意，为防止大批 key 同时过期，导致 redis 频繁扫描影响性能。**建议将过期时间随机化，防止同时过期。** <br />
　　从库不会进行过期扫描，而是进行主从同步，存在主从延迟情况。

- 定时删除（主动删除），对内存友好，但对 CPU 不友好。在 CPU 使用高峰时，执行定时删除，会影响其性能。同时，创建定时器用到 Redis 服务器的时间事件，它是使用无序链表，导致查找一个事件的时间复杂度为 O(N)；
- 惰性删除（被动删除），对 CPU 时间最友好，但对内存最不友好。 获取键时，检查是否过期，过期则删除。如果有很多键没有访问获取（数据太旧），则没法删除，相当于内存泄漏；
- 定期删除（主动删除），前两种的折中。 设定删除操作执行的时长，每隔一段时间，检查一次并删除。

### [Redis 内存淘汰机制](https://github.com/martin-1992/redis_notebook/tree/master/Redis%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6)
　　当 Redis 的内存超过期望内存 maxmemory 时，会执行内存淘汰机制。Redis 的过期机制有可能会导致内存泄漏，需要对 key 执行淘汰策略。<br />
　　常用的有近似 LRU 算法，Redis 随机抽取 5 个 key，检查这 5 个 key 最后一次的访问时间戳，丢弃最旧的那个，一直重复该流程。

### [布隆过滤器](https://github.com/martin-1992/redis_notebook/tree/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)
　　**内存占用小，解决缓存穿透的方法。** 缓存穿透指查询不存在的值，会去存储层查询。大流量情况下，会对存储层造成大的负担。<br />
　　**它由一个 bit 数组和一组 Hash 算法构成，可用于判断一个元素是否在一个集合中。** 它是将所有地址经过多个 Hash 算法，映射到一个 bit 数组，其数学原理在于两个完全随机的数字相冲突的概率很小。

### [Redis 分布式锁](https://github.com/martin-1992/redis_notebook/tree/master/Redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)
　　
- 使用 jedis 客户端，自己实现分布式锁；
- Redission 封装了分布式锁的实现，可直接调用；
- RedLock，解决主从的锁同步问题。
    1. 比如机器 A 向主机器申请锁，这锁没有同步到 B 机器，然后主机器宕机了。这时 B 机器去从机器能申请到锁；
    2. RedLock 解决方法是使用少数服从多数原则，机器 A 申请锁时，是向多个 redis 机器申请锁，当获得多数锁时，才成功获取锁，适用于更严格的场景。

