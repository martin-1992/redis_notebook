## 简单动态字符串
　　Redis 构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示，而 C 字符串只作为字面量。

### SDS 的定义
　　在 sds.h / sdshdr 结构表示一个 SDS 值。

![avatar](chapter_2_p1.png)

- free = 0，表示这个 SDS 的剩余空间已经用完；
- len = 5，表示这个 SDS 保存一个 5 字节长的字符串，执行 STRLEN 命令，返回该值，所以时间复杂度为 O(1)；
- buf 属性是一个 char 类型的数组，数组的前五个字节分别保存了 "R"、"e"、"d"、"i"、"s" 五个字符，最后一个字节保存空字符 "\0"，这个空字节占据一个字节长度，但不计算在 len 里。使用空字节进行结尾，SDS 可以直接重用一部分 C 字符串函数库里的函数，如 printf；

### 杜绝缓冲区溢出
　　C 字符串不记录自身长度，容易造成缓冲区溢出没，如下图。

![avatar](chapter_2_p2.png)

![avatar](chapter_2_p3.png)

　　而 SDS 的 API 会先检查 SDS 的空间是否满足修改所需的要求，不满足会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，从而避免缓冲区溢出问题，即 s1 的内容覆盖到 s2，导致 s2 的内容被修改。

### 减少修改字符串时带来的内存重分配次数
　　SDS 则通过未使用的空间来实现空间预分配和惰性空间释放两种优化策略。

- **空间预分配，用于优化 SDS 的字符串增长操作。** 当 SDS 的API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展时，程序不仅会为 SDS 分配修改所需要的空间，还会为 SDS 分配额外的未使用空间；
  1. 如果 SDS 的长度（len 属性的值）小于 1MB，则分配和 len 属性同样大小的未使用空间，如在修改后，SDS 的 len 变成 13 字节，那么程序也会分配 13 字节未使用空间。这样 buf 数组的实际长度为 13 + 13 + 1（额外一节保存空字符）= 27 字节；
  2. 如果 SDS 的长度大于等于 1MB，程序则分配 1MB 的未使用空间，即 30MB + 1MB + 1byte（保存空字符）。通过空间预分配策略，来减少连续执行字符串增长操作所需的内存重分配次数。
- **惰性空间释放，用于优化 SDS 的字符串缩短操作。** 当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序不会对内存重新分配来回收缩短后多出来的字节，而是留着以后字符粗增长使用。如需要释放，也可以使用对应的 API 进行手动释放内存。

### 二进制安全
　　SDS 以处理二进制的方式来保存数据，这样 Redis 不仅可以保存文本数据，还可以保存图片、音频、视频等二进制数据。

### 总结
　　对 C 字符串和 SDS 之间区别的总结：

- C 字符串获取字符串长度的复杂度为 O(N)。SDS 获取字符串长度的复杂度为 O(1)，有个 len 属性记录长度；
- C 字符串 API 不安全，在增加字符串时不进行内存分配下，可能会造成缓冲区溢出。SDS API 是安全的，在增加字符串时会对其内存进行检查，有需要时增加内存，不会造成缓冲区溢出；
- C 字符串修改字符串长度 N 次必须执行 N 次内存重分配。SDS 修改字符串长度 N 次最多需要执行 N 次内存重分配，使用空间预分配和惰性空间释放策略；
- C 字符串只能保存文本数据。SDS 能保存文本或二进制数据；
- C 字符串可使用所有的 &lt;string.h&gt; 库中的函数。而 SDS 只能使用部分 &lt;string.h&gt; 库中的函数；
